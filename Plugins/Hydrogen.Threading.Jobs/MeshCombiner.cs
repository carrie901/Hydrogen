#region Copyright Notice & License Information
//
// Regex.cs
//
// Author:
//       Matthew Davey <matthew.davey@dotbunny.com>
//       Robin Southern <betajaen@ihoed.com>
//
// Copyright (c) 2013 dotBunny Inc. (http://www.dotbunny.com)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
#endregion

using System;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Hydrogen.Threading.Jobs
{
		public class MeshCombiner : ThreadPoolJob
		{
				Action<int, UnityEngine.Mesh[]> _callback;
				/// <summary>
				/// An array of MeshDescriptions generated by the Combine method. 
				/// </summary>
				MeshDescription[] _combinedDescriptions;
				/// <summary>
				/// An array of Materials generated by the Combine method.
				/// </summary>
				Material[] _combinedMaterials;
				/// <summary>
				/// An array of Meshes generated by the Combine method.
				/// </summary>
				UnityEngine.Mesh[] _combinedMeshes;
				/// <summary>
				/// An internal hash used to identify the Combine method instance.
				/// </summary>
				int _hash;
				/// <summary>
				/// An internally used datastore housing added mesh data to be combined by the Combine method.
				/// </summary>
				MeshDescription[] _meshDescriptions;

				/// <summary>
				/// Gets the array of MeshDescriptions generated by the Combine method. 
				/// </summary>
				/// <value>The the combined MeshDescritions.</value>
				public MeshDescription[] CombinedDescriptions {
						get { return _combinedDescriptions; }
				}

				/// <summary>
				/// Gets the array of Materials generated by the Combine method.
				/// </summary>
				/// <value>The combined Materials.</value>
				public Material[] CombinedMaterials {
						get { return _combinedMaterials; }
				}

				/// <summary>
				/// Gets the array of Meshes generated by the Combine method.
				/// </summary>
				/// <value>The combined Meshes.</value>
				public UnityEngine.Mesh[] CombinedMeshes {
						get { return _combinedMeshes; }
				}

				/// <summary>
				/// Creates a thread safe dataset used when combining meshes via the MeshCombiner.
				/// </summary>
				/// <returns>The parsed MeshDescription.</returns>
				/// <param name="mesh">Target Mesh.</param>
				/// <param name="transform">Target Transform.</param>
				public static MeshDescription CreateDescription (UnityEngine.Mesh mesh, Transform transform)
				{
						var vertexCount = mesh.vertexCount;
						var md = new MeshDescription (vertexCount);

						md.vertexObject.vertices.CopyFrom (mesh.vertices);
						md.vertexObject.normals.CopyFrom (mesh.normals);
						md.vertexObject.tangents.CopyFrom (mesh.tangents);
						md.vertexObject.colours.CopyFrom (mesh.colors);
						md.vertexObject.uv.CopyFrom (mesh.uv);
						md.vertexObject.uv1.CopyFrom (mesh.uv1);
						md.vertexObject.uv2.CopyFrom (mesh.uv2);
						md.vertexObject.worldTransform = transform.localToWorldMatrix;

						var nbSubMeshes = mesh.subMeshCount;

						for (var j = 0; j < nbSubMeshes; j++) {
								Material mat = null;
								var indices = mesh.GetIndices (j);
								var sm = md.AddSubMesh (mat, indices.Length);
								sm.indices.CopyFrom (indices);
						} 

						return md;
				}

				/// <summary>
				/// Creates the thread safe dataset used when combining meshes via the MeshCombiner.
				/// </summary>
				/// <returns>The parsed MeshDescriptions.</returns>
				/// <param name="meshes">Target Mesh.</param>
				/// <param name="transforms">Target Transform.</param>
				public static MeshDescription[] CreateDescriptions (UnityEngine.Mesh[] meshes, Transform[] transforms)
				{
						var mds = new MeshDescription[meshes.Length];

						for (int i = 0; i < meshes.Length; i++) {
								mds [i] = CreateDescription (meshes [i], transforms [i]);
						}
						return mds;
				}

				/// <summary>
				/// Add a Mesh to be combined.
				/// </summary>
				/// <returns><c>true</c>, if mesh was added, <c>false</c> otherwise.</returns>
				/// <param name="meshDescription">The MeshDescription to be added.</param>
				public bool AddMesh (MeshDescription meshDescription)
				{
						return Array.Add<MeshDescription> (ref _meshDescriptions, meshDescription);
				}

				/// <summary>
				/// Add a Mesh to be combined.
				/// </summary>
				/// <returns><c>true</c>, if mesh was added, <c>false</c> otherwise.</returns>
				/// <param name="mesh">The Mesh to be added.</param>
				/// <param name="transform">The Mesh's transform.</param>
				public bool AddMesh (UnityEngine.Mesh mesh, Transform transform)
				{
						return Array.Add<MeshDescription> (ref _meshDescriptions, CreateDescription (mesh, transform));
				}

				public int Combine (Action<int, UnityEngine.Mesh[]> onFinished)
				{
						return Combine (System.Threading.ThreadPriority.Normal, onFinished);
				}

				public int Combine (System.Threading.ThreadPriority priority, Action<int, UnityEngine.Mesh[]> onFinished)
				{
						// Generate Hash Code
						_hash = (Time.time + UnityEngine.Random.Range (0, 100)).GetHashCode ();

						// Start the threaded prcess
						if (onFinished != null) {
								_callback = onFinished;
						}

						Start (true, priority);

						return _hash;
				}

				public bool RemoveMesh (MeshDescription meshDescription)
				{
						return Array.Remove (ref _meshDescriptions, meshDescription);
				}

				protected sealed override void ThreadedFunction ()
				{
						_combinedDescriptions = CombineMeshDescriptions (_meshDescriptions);
				}

				protected sealed override void OnFinished ()
				{
						// Create our mesh
						//ProcessMeshes ();
						_combinedMeshes = MakeMeshes (_combinedDescriptions);
						_combinedMaterials = MakeMaterials (_combinedDescriptions);

						// Callback
						if (_callback != null) {
								_callback (_hash, _combinedMeshes);
						}

				}

				public  UnityEngine.Mesh[] OptimiseMeshes (UnityEngine.Mesh[] meshes)
				{
						return null;
				}

				MeshDescription[] CombineMeshDescriptions (MeshDescription[] descriptions)
				{
						var materials = UniqueMaterials (descriptions);
						var mmds = new MultiMeshDescription[materials.Length];

						for (int i = 0; i < materials.Length; i++) {
								mmds [i] = new MultiMeshDescription (materials [i]);
						}

						var mds = new MeshDescription[materials.Length];

						foreach (var d in descriptions) {
								foreach (var sm in d.subMeshes) {
										foreach (var mmd in mmds) {
												if (mmd.sharedMaterial == sm.sharedMaterial) {
														mmd.AddSubMesh (sm);
														break;
												}
										}
								}
						}

						var fmds = new List<MeshDescription> (mds.Length);
						foreach (var mmd in mmds) {
								fmds.AddRange (mmd.Combine ());
						}

						return fmds.ToArray ();
				}

				Material[] MakeMaterials (MeshDescription[] materials)
				{
						return null;
				}

				UnityEngine.Mesh[] MakeMeshes (MeshDescription[] meshes)
				{
						return null;
				}

				MeshDescription[] OptimiseMeshesDescriptions (MeshDescription[] meshDescriptions)
				{
						return null;
				}

				Material[] UniqueMaterials (MeshDescription[] desc)
				{
						var seen = new List<Material> (desc.Length);
						foreach (var m in desc) {
								foreach (var sm in m.subMeshes) {
										if (seen.Contains (sm.sharedMaterial) == false) {
												seen.Add (sm.sharedMaterial);
										}
								}
						}
						return seen.ToArray ();
				}

				public bool IsSame (Material lhs, Material rhs)
				{
						// Just for now.
						return lhs.Equals (rhs);
				}

				public class VertexArrayDescription<T>
				{
						readonly T[] values;
						public readonly int size;

						public bool hasValues { get; private set; }

						public VertexArrayDescription (int nbVertices)
						{
								size = nbVertices;
								values = new T[size];
								hasValues = false;
						}

						public T this [int i] {
								get { return values [i]; }
								set {
										values [i] = value;
										hasValues = true;
								}
						}

						public void CopyFrom (T[] other)
						{
								if (other != null && other.Length > 0) {
										// TODO Exception/Assert here when size != values.length
										for (var i = 0; i < size; i++) {
												values [i] = other [i];
										}
										hasValues = true;
								}
						}
				}

				public class IndexArrayDescription
				{
						readonly int[] values;

						public int size { get; private set; }

						public IndexArrayDescription (int nbIndexes)
						{
								size = nbIndexes;
								if (size % 3 != 0) {
										Debug.Log ("Bad index array, count is not a multiple of 3!");
										return;
								}
								values = new int[size];
						}

						public int this [int i] {
								get { return values [i]; }
								set { values [i] = value; }
						}

						internal void CopyFrom (int[] other)
						{
								for (var i = 0; i < size; i++) {
										values [i] = other [i];
								}
						}
				}

				public class MeshDescription
				{
						public readonly VertexObjectDescription vertexObject;
						public readonly List<SubMeshDescription> subMeshes;

						public MeshDescription (int nbVertices)
						{
								vertexObject = new VertexObjectDescription (nbVertices);
								subMeshes = new List<SubMeshDescription> ();
						}

						public SubMeshDescription AddSubMesh (Material sharedMaterial, int nbIndexes)
						{
								var smd = new SubMeshDescription (nbIndexes, vertexObject, sharedMaterial);
								subMeshes.Add (smd);
								return smd;
						}

						internal void DebugPrint (StringBuilder sb)
						{
								sb.AppendFormat ("Mesh#{0:X8}\n", GetHashCode ());
								sb.AppendFormat ("Vertices.Size={0}\n", vertexObject.size);
								sb.AppendFormat ("Vertices.Vertices =[{0},{1},{2}], [{3},{4},{5}], [{6},{7},{8}]...\n", vertexObject.vertices [0].x, vertexObject.vertices [1].y, vertexObject.vertices [2].z, vertexObject.vertices [3].x, vertexObject.vertices [4].y, vertexObject.vertices [5].z, vertexObject.vertices [6].x, vertexObject.vertices [7].y, vertexObject.vertices [8].z);
								sb.AppendFormat ("Vertices.Normals={0}\n", vertexObject.normals.hasValues);
								sb.AppendFormat ("Vertices.Tangents={0}\n", vertexObject.tangents.hasValues);
								sb.AppendFormat ("Vertices.Colours={0}\n", vertexObject.colours.hasValues);
								sb.AppendFormat ("Vertices.UV={0}\n", vertexObject.uv.hasValues);
								sb.AppendFormat ("Vertices.UV1={0}\n", vertexObject.uv1.hasValues);
								sb.AppendFormat ("Vertices.UV2={0}\n", vertexObject.uv2.hasValues);
								sb.AppendFormat ("Vertices.WorldTransform={0}\n", vertexObject.worldTransform.ToString ().Replace ('\n', ' '));
								sb.AppendFormat ("SubMesh.Count={0}\n", subMeshes.Count);
								for (var i = 0; i < subMeshes.Count; i++) {
										var sm = subMeshes [i];
										sb.AppendFormat ("SubMesh[{0}].Indexes={1}\n", i, sm.indices.size);
								}
						}
				}

				public class MultiMeshDescription
				{
						public readonly Material sharedMaterial;
						public readonly List<SubMeshDescription> subMeshes;

						public MultiMeshDescription (Material material)
						{
								this.sharedMaterial = material;
								this.subMeshes = new List<SubMeshDescription> (4);
						}

						public void AddSubMesh (SubMeshDescription sm)
						{
								subMeshes.Add (sm);
						}

						public MeshDescription[] Combine ()
						{
								var mds = new List<MeshDescription> ();

								int totalNbVertices = 0;
								foreach (var sm in subMeshes) {
										totalNbVertices += sm.CountUsedVertices ();
								}

								// Divide up meshes equally with a maxium vertex limit
								var nbVerticesPerMesh = new List<int> ();
								int vertexCount = 0;
								while (vertexCount != totalNbVertices) {
										int used = vertexCount;
										if (used > (Hydrogen.Mesh.VerticesLimit - 6))
												used = Hydrogen.Mesh.VerticesLimit - 6;
										nbVerticesPerMesh.Add (used);
										vertexCount += used;
								}

								// ROBIN - UPTO HERE.

								return null;
						}
				}

				public class SubMeshDescription
				{
						public readonly Material sharedMaterial;
						public readonly IndexArrayDescription indices;
						public readonly VertexObjectDescription vertexObject;
						public readonly int[] used;

						public SubMeshDescription (int nbIndexes, VertexObjectDescription vertices, Material material)
						{
								this.sharedMaterial = material;
								this.vertexObject = vertices;
								this.indices = new IndexArrayDescription (nbIndexes);
								this.used = new int[vertices.size];
						}

						public int CountUsedVertices ()
						{
								int count = 0;

								// Count used vertices.  This uses an 'if-less' solution so should be faster but uses 4x (int > bool) memory do to so.
								for (int i = 0; i < used.Length; i++)
										used [i] = 0;

								for (int i = 0; i < indices.size; i++)
										used [indices [i]] = 1;

								for (int i = 0; i < indices.size; i++)
										count += used [i];

								return count;
						}
				}

				public class VertexObjectDescription
				{
						public readonly int size;
						public readonly VertexArrayDescription<Vector3> vertices;
						public readonly VertexArrayDescription<Vector3> normals;
						public readonly VertexArrayDescription<Vector4> tangents;
						public readonly VertexArrayDescription<Color> colours;
						public readonly VertexArrayDescription<Vector2> uv;
						public readonly VertexArrayDescription<Vector2> uv1;
						public readonly VertexArrayDescription<Vector2> uv2;
						public readonly VertexArrayDescription<bool> used;
						public Matrix4x4 worldTransform;

						public VertexObjectDescription (int nbVertices)
						{
								size = nbVertices;
								vertices = new VertexArrayDescription<Vector3> (size);
								normals = new VertexArrayDescription<Vector3> (size);
								tangents = new VertexArrayDescription<Vector4> (size);
								colours = new VertexArrayDescription<Color> (size);
								uv = new VertexArrayDescription<Vector2> (size);
								uv1 = new VertexArrayDescription<Vector2> (size);
								uv2 = new VertexArrayDescription<Vector2> (size);
								used = new VertexArrayDescription<bool> (size);
								worldTransform = Matrix4x4.identity;
						}
				}
		}
}
